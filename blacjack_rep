
# import numpy as np

# from ultralytics import YOLO
# import cv2

# model = YOLO("runs/detect/cards_yolov8m_new_dataset3/weights/best.pt")


# cap = cv2.VideoCapture(0)

# frame_count = 0

# def draw_virtual_blackjack(frame, detections):
#     h, w, _ = frame.shape
#     table = np.zeros_like(frame)
#     table[:] = (0, 100, 0)  # green background

#     # Divide detections into player and dealer hands
#     player_cards = []
#     dealer_cards = []

#     for det in detections:
#         x1, y1, x2, y2 = map(int, det['bbox'])
#         cx = (x1 + x2) // 2
#         cy = (y1 + y2) // 2

#         label = det['label']

#         # Use vertical position to assign to player or dealer
#         if cy > h // 2:
#             player_cards.append((cx, label))
#         else:
#             dealer_cards.append((cx, label))

#     # Sort cards left to right
#     player_cards.sort()
#     dealer_cards.sort()

#     # Draw cards
#     def draw_hand(cards, y_pos, label):
#         spacing = 100
#         start_x = w//2 - len(cards)//2 * spacing
#         cv2.putText(table, label, (start_x, y_pos - 40), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (255,255,255), 2)
#         for i, (_, lbl) in enumerate(cards):
#             x = start_x + i * spacing
#             cv2.rectangle(table, (x, y_pos), (x+60, y_pos+90), (255,255,255), -1)
#             cv2.putText(table, lbl, (x+10, y_pos+50), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0,0,0), 2)

#     draw_hand(dealer_cards, y_pos=80, label="Dealer")
#     draw_hand(player_cards, y_pos=h-180, label="Player")

#     return table

# while True:
#     ret, frame = cap.read()
#     if not ret:
#         print("‚ùå Failed to grab frame")
#         break

#     frame_count += 1
#     print(f"üì∑ Processing frame {frame_count}...")

#     results = model.predict(source=frame, conf=0.4, stream=False)
#     result = results[0]

#     detections = []
#     if result.boxes is not None and len(result.boxes) > 0:
#         print(f"‚úÖ Detected {len(result.boxes)} objects")
#         for box, cls in zip(result.boxes.xyxy, result.boxes.cls):
#             x1, y1, x2, y2 = box.tolist()
#             class_id = int(cls.item())
#             label = model.names[class_id]
#             detections.append({"bbox": (x1, y1, x2, y2), "label": label})
#     else:
#         print("‚ö†Ô∏è No detections")

#     virtual_table = draw_virtual_blackjack(frame, detections)

#     # Combine original + virtual view
#     combined = np.vstack((cv2.resize(frame, (frame.shape[1], 300)),
#                           cv2.resize(virtual_table, (frame.shape[1], 300))))

#     cv2.imshow("Blackjack Live View", combined)

#     if cv2.waitKey(1) == 27:
#         break

# cap.release()
# cv2.destroyAllWindows()

# import numpy as np

# from ultralytics import YOLO
# import cv2

# model = YOLO("runs/detect/cards_yolov8m_new_dataset3/weights/best.pt")

# cap = cv2.VideoCapture(0)

# frame_count = 0

# def iou(boxA, boxB):
#     xA = max(boxA[0], boxB[0])
#     yA = max(boxA[1], boxB[1])
#     xB = min(boxA[2], boxB[2])
#     yB = min(boxA[3], boxB[3])

#     interArea = max(0, xB - xA) * max(0, yB - yA)
#     if interArea == 0:
#         return 0

#     boxAArea = (boxA[2] - boxA[0]) * (boxA[3] - boxA[1])
#     boxBArea = (boxB[2] - boxB[0]) * (boxB[3] - boxB[1])

#     return interArea / float(boxAArea + boxBArea - interArea)

# def remove_duplicate_labels(detections):
#     seen_labels = set()
#     filtered = []
#     for det in sorted(detections, key=lambda d: d.get("conf", 1.0), reverse=True):
#         if det['label'] not in seen_labels:
#             filtered.append(det)
#             seen_labels.add(det['label'])
#     return filtered

# def draw_virtual_blackjack(frame, detections):
#     h, w, _ = frame.shape
#     table = np.zeros_like(frame)
#     table[:] = (0, 100, 0)  # green background

#     # Divide detections into player and dealer hands
#     player_cards = []
#     dealer_cards = []

#     unique_detections = remove_duplicate_labels(detections)

#     for det in unique_detections:
#         x1, y1, x2, y2 = map(int, det['bbox'])
#         cx = (x1 + x2) // 2
#         cy = (y1 + y2) // 2
#         label = det['label']

#         if cy > h // 2:
#             player_cards.append((cx, label))
#         else:
#             dealer_cards.append((cx, label))

#     player_cards.sort()
#     dealer_cards.sort()

#     def draw_hand(cards, y_pos, label):
#         spacing = 100
#         start_x = w//2 - len(cards)//2 * spacing
#         cv2.putText(table, label, (start_x, y_pos - 40), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (255,255,255), 2)
#         for i, (_, lbl) in enumerate(cards):
#             x = start_x + i * spacing
#             cv2.rectangle(table, (x, y_pos), (x+60, y_pos+90), (255,255,255), -1)
#             cv2.putText(table, lbl, (x+10, y_pos+50), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0,0,0), 2)

#     draw_hand(dealer_cards, y_pos=80, label="Dealer")
#     draw_hand(player_cards, y_pos=h-180, label="Player")

#     return table

# while True:
#     ret, frame = cap.read()
#     if not ret:
#         print("‚ùå Failed to grab frame")
#         break

#     frame_count += 1
#     print(f"üì∑ Processing frame {frame_count}...")

#     results = model.predict(source=frame, conf=0.4, stream=False)
#     result = results[0]

#     detections = []
#     if result.boxes is not None and len(result.boxes) > 0:
#         print(f"‚úÖ Detected {len(result.boxes)} objects")
#         for box, cls, conf in zip(result.boxes.xyxy, result.boxes.cls, result.boxes.conf):
#             x1, y1, x2, y2 = box.tolist()
#             class_id = int(cls.item())
#             label = model.names[class_id]
#             detections.append({"bbox": (x1, y1, x2, y2), "label": label, "conf": conf.item()})
#     else:
#         print("‚ö†Ô∏è No detections")

#     virtual_table = draw_virtual_blackjack(frame, detections)

#     combined = np.vstack((cv2.resize(frame, (frame.shape[1], 300)),
#                           cv2.resize(virtual_table, (frame.shape[1], 300))))

#     cv2.imshow("Blackjack Live View", combined)

#     if cv2.waitKey(1) == 27:
#         break

# cap.release()
# cv2.destroyAllWindows()
import numpy as np
import cv2
import tkinter as tk
from tkinter import ttk
from ultralytics import YOLO

# Global variable for number of players
NUM_PLAYERS = 3
show_result = False

# GUI to select number of players
root = tk.Tk()
root.title("Select Number of Players")
root.geometry("300x160")

label = tk.Label(root, text="Select Number of Players:", font=("Helvetica", 12))
label.pack(pady=(10, 0))

player_var = tk.IntVar(value=3)
tt = ttk.Combobox(root, textvariable=player_var, values=list(range(1, 7)), state="readonly")
tt.pack(pady=10)
tt.set("3")

confirmed = tk.BooleanVar(value=False)

def confirm():
    global NUM_PLAYERS
    NUM_PLAYERS = player_var.get()
    confirmed.set(True)
    root.destroy()

btn = ttk.Button(root, text="Start", command=confirm)
btn.pack()
root.wait_variable(confirmed)

# Model and capture
model = YOLO("runs/detect/cards_yolov8m_new_dataset_secondtry2/weights/best.pt")
cap = cv2.VideoCapture(0)
cv2.namedWindow("Blackjack Live View", cv2.WND_PROP_FULLSCREEN)
cv2.setWindowProperty("Blackjack Live View", cv2.WND_PROP_FULLSCREEN, cv2.WINDOW_FULLSCREEN)
frame_count = 0

CARD_VALUES = {
    'A': [1, 11], '2': [2], '3': [3], '4': [4], '5': [5], '6': [6],
    '7': [7], '8': [8], '9': [9], '10': [10], 'J': [10], 'Q': [10], 'K': [10]
}

def parse_card_value(label):
    for key in CARD_VALUES:
        if key in label.upper():
            return CARD_VALUES[key]
    return []

def best_blackjack_score(card_labels):
    all_scores = [0]
    for label in card_labels:
        values = parse_card_value(label)
        if not values:
            continue
        new_scores = []
        for s in all_scores:
            for v in values:
                new_scores.append(s + v)
        all_scores = new_scores
    valid_scores = [s for s in all_scores if s <= 21]
    return max(valid_scores) if valid_scores else min(all_scores)

def iou(boxA, boxB):
    xA = max(boxA[0], boxB[0])
    yA = max(boxA[1], boxB[1])
    xB = min(boxA[2], boxB[2])
    yB = min(boxA[3], boxB[3])
    interArea = max(0, xB - xA) * max(0, yB - yA)
    if interArea == 0:
        return 0
    boxAArea = (boxA[2] - boxA[0]) * (boxA[3] - boxA[1])
    boxBArea = (boxB[2] - boxB[0]) * (boxB[3] - boxB[1])
    return interArea / float(boxAArea + boxBArea - interArea)

def remove_duplicate_labels(detections):
    seen_labels = set()
    filtered = []
    for det in sorted(detections, key=lambda d: d.get("conf", 1.0), reverse=True):
        if det['label'] not in seen_labels:
            filtered.append(det)
            seen_labels.add(det['label'])
    return filtered

def draw_virtual_blackjack(frame, detections):
    h, w, _ = frame.shape
    table = np.zeros_like(frame)
    table[:] = (0, 100, 0)  # green background

    dealer_cards = []
    player_hands = [[] for _ in range(NUM_PLAYERS)]
    seen_labels = set()

    for det in remove_duplicate_labels(detections):
        x1, y1, x2, y2 = map(int, det['bbox'])
        cx = (x1 + x2) // 2
        cy = (y1 + y2) // 2
        label = det['label']

        if label in seen_labels:
            continue
        seen_labels.add(label)

        if cy < h // 3:
            dealer_cards.append((cx, label))
        else:
            player_index = min(NUM_PLAYERS - 1, (cx * NUM_PLAYERS) // w)
            player_hands[player_index].append((cx, label))

    dealer_cards.sort()
    for hand in player_hands:
        hand.sort()

    dealer_labels = [lbl for _, lbl in dealer_cards]
    dealer_score = best_blackjack_score(dealer_labels)
    spacing = 60
    start_x = w//2 - len(dealer_cards)//2 * spacing
    dealer_label = f"Dealer ({dealer_score})"
    cv2.putText(table, dealer_label, (start_x, 40), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (255,255,255), 2)
    for i, (_, lbl) in enumerate(dealer_cards):
        x = start_x + i * spacing
        cv2.rectangle(table, (x, 60), (x+40, 120), (255,255,255), -1)
        cv2.putText(table, lbl, (x+5, 100), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,0,0), 1)

    for i in range(NUM_PLAYERS):
        x_start = i * w // NUM_PLAYERS
        x_end = (i + 1) * w // NUM_PLAYERS
        cv2.line(table, (x_end, h//2), (x_end, h), (255, 255, 255), 2)
        card_labels = [lbl for _, lbl in player_hands[i]]
        score = best_blackjack_score(card_labels)
        result = ""
        if show_result:
            if score > 21:
                result = "BUST"
            elif dealer_score > 21 or score > dealer_score:
                result = "WIN"
            elif score == dealer_score:
                result = "PUSH"
            else:
                result = "LOSE"
        label = f"Player {i+1} ({score}) {result}"
        cv2.putText(table, label, (x_start + 10, h//2 + 30), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255, 255, 255), 2)
        cards = player_hands[i]
        spacing = min(50, (x_end - x_start) // (len(cards) + 1)) if cards else 50
        start_x = x_start + (x_end - x_start)//2 - len(cards)//2 * spacing
        for j, (_, lbl) in enumerate(cards):
            x = start_x + j * spacing
            cv2.rectangle(table, (x, h - 120), (x+40, h - 60), (255,255,255), -1)
            cv2.putText(table, lbl, (x+5, h - 75), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,0,0), 1)

    return table

while True:
    ret, frame = cap.read()
    if not ret:
        print("‚ùå Failed to grab frame")
        break

    frame_count += 1
    print(f"üì∑ Processing frame {frame_count}...")

    results = model.predict(source=frame, conf=0.4, stream=False)
    result = results[0]

    detections = []
    if result.boxes is not None and len(result.boxes) > 0:
        print(f"‚úÖ Detected {len(result.boxes)} objects")
        for box, cls, conf in zip(result.boxes.xyxy, result.boxes.cls, result.boxes.conf):
            x1, y1, x2, y2 = box.tolist()
            class_id = int(cls.item())
            label = model.names[class_id]
            detections.append({"bbox": (x1, y1, x2, y2), "label": label, "conf": conf.item()})
    else:
        print("‚ö†Ô∏è No detections")

    h, w, _ = frame.shape
    for i in range(1, NUM_PLAYERS):
        x_line = i * w // NUM_PLAYERS
        cv2.line(frame, (x_line, h//2), (x_line, h), (255, 255, 255), 2)

    virtual_table = draw_virtual_blackjack(frame, detections)

    combined = np.vstack((cv2.resize(frame, (frame.shape[1], frame.shape[0] // 2)),
                          cv2.resize(virtual_table, (frame.shape[1], frame.shape[0] // 2))))

    cv2.imshow("Blackjack Live View", combined)

    key = cv2.waitKey(1)
    if key == 27:  # ESC to quit
        break
    elif key == ord('r'):  # Press 'r' to toggle result evaluation
        show_result = not show_result

cap.release()
cv2.destroyAllWindows()
